% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/d.spls.GL.R
\name{d.spls.GL}
\alias{d.spls.GL}
\title{Dual Sparse Partial Least Squares (Dual-SPLS) regression for the group lasso norms}
\usage{
d.spls.GL(X,y,ncp,ppnu,indG,gamma=NULL,norm="A",verbose=FALSE)
}
\arguments{
\item{X}{a numeric matrix of predictors values. Each row represents an observation and each column a predictor variable.}

\item{y}{a numeric vector or a one column matrix of responses. It represents the response variable for each converstation.}

\item{ncp}{a positive integer. \code{ncp} is the number of Dual-SPLS components.}

\item{ppnu}{a positive real value or a vector of length the number of groups, in \eqn{[0,1]}.
\code{ppnu} is the desired proportion of variables to shrink to zero for each component and for each group.}

\item{indG}{a numeric vector of group index for each observation.}

\item{gamma}{a numeric vector of the norm \eqn{\Omega} of each \eqn{w_g} in case \code{norm="B"}. Default value is \code{NULL}.}

\item{norm}{a character specifying the norm chosen between A, B and C. Default value is \code{A}.}

\item{verbose}{a boolean value indicating whether or not to diplay the iterations steps. Default value is \code{FALSE}.}
}
\value{
A \code{list} of the following attributes
\item{Xmean}{the mean vector of the predictors matrix \code{X}.}
\item{scores}{the matrix of dimension \code{n x ncp} where \code{n} is the number of observations.The \code{scores} represents
the observations in the new component basis computed by the compression step
of the Dual-SPLS.}
\item{loadings}{the matrix of dimension \code{p x ncp} that represents the Dual-SPLS components.}
\item{Bhat}{the matrix of dimension \code{p x ncp} that regroups the regression coefficients for each component.}
\item{intercept}{the vector of length \code{ncp} representing the intercept values for each component.}
\item{fitted.values}{the matrix of dimension \code{n x ncp} that represents the predicted values of \code{y}}
\item{residuals}{the matrix of dimension \code{n x ncp} that represents the residuals corresponding
to the difference between the responses and the fitted values.}
\item{lambda}{the matrix of dimension \code{G x ncp} collecting the parameters of sparsity \eqn{\lambda_g} used to fit the model at each iteration and for each group.}
\item{alpha}{the matrix of dimension \code{G x ncp} collecting the constraint parameters \eqn{\alpha_g}  used to fit the model at each iteration and for each group when the norm chosen is \code{B} or \code{C}.}
\item{zerovar}{the matrix of dimension \code{G x ncp} representing the number of variables shrinked to zero per component and per group.}
}
\description{
The function \code{d.spls.GL} performs dimentional reduction as in PLS methodology combined to variable selection using the
Dual-SPLS algorithm with the group lasso norms
\itemize{
\item Norm A: \eqn{\Omega(w)=\|w\|_2+\sum\limits_{g=1}^G \lambda_g\|w_g\|_1}
\item Norm B: \eqn{\Omega(w)=\sum\limits_{g=1}^G \alpha_g \|w \|_2+\sum\limits_{g=1}^G \lambda_g \|w_g \|_1} for
\eqn{\sum\limits_{g=1}^G \alpha_g=1; \Omega(w_g)=\gamma_g ;\sum\limits_{g=1}^G \gamma_g=1}
\item Norm C: \eqn{\Omega(w)=\|w_g\|_2+ \lambda_g \|w_g\|_1} for
\eqn{\Omega(w)=\sum_{g} \alpha_g \Omega_g(w)=1; \sum\limits_{g=1}^G \alpha_g=1}
}
Where \code{G} is the number of groups.
}
\details{
This procedure computes latent sparse components that are used in a regression model.
The optimization problem of the Dual-SPLS regression for the group lasso norms comes from
to the Dual norm defintion of the norm \eqn{\Omega(w)}. Indeed, we are searching for \code{w} that goes with
\deqn{\Omega^*(z)=\max\limits_w(z^Tw) \textrm{ s.t. } \Omega(w)=1}
Noting that \eqn{\lambda_g} are the initial shrinkage parameters that imposes sparsity, the Dual-SPLS does not rely
on the values of \eqn{\lambda_g} but instead proceeds adaptively by choosing the propotion of zeros that the user
would like to impose in the coefficients for each group. Which leads to the compuation of a secondary shrinkage parameter \eqn{\nu_g}.

The solution of this problem for the norm \code{A} is
\deqn{\frac{w_g}{\|w\|_2}=\frac{1}{\mu} \delta_g (|z_g|-\nu_g)_+ \textrm{ for each group } g}
The solution of this problem for the norm \code{B} is
\deqn{\frac{w_g}{\|w\|_2}=\frac{1}{\mu \alpha_g} \delta_g (|z_g|-\nu_g)_+ \textrm{ for each group } g}
The solution of this problem for the norm \code{C} is
\deqn{\frac{w_g}{\|w_g\|_2}=\frac{1}{\mu \alpha_g} \delta_g (|z_g|-\nu_g)_+ \textrm{ for each group } g}
Where
\itemize{
\item \eqn{\delta_g} is the vector of signs of \eqn{z_g} and \eqn{w_g}
\item \eqn{\alpha_g} is a constraint parameter imposed for norms \code{B} and \code{C}.
\item \eqn{\mu} is a parameter that guarentees the constraint of \eqn{\Omega(w)=1}
\item \eqn{\nu_g} is the shrinkage parameter for each group \code{g}.
}
}
\examples{
### load dual.spls library
library(dual.spls)

####two predictors matrix
### parameters
n <- 100
p <- c(50,100)
nondes <- c(20,30)
sigmaondes <- c(0.05,0.02)
data=d.spls.simulate(n=n,p=p,nondes=nondes,sigmaondes=sigmaondes)

X <- data$X
X1 <- X[,(1:p[1])]
X2 <- X[,(p[1]+1):p[2]]
y <- data$y

indG <-c(rep(1,p[1]),rep(2,p[2]))

#fitting the model
ncp <- 10
ppnu <- c(0.99,0.9)

# norm A
mod.dsplsA <- d.spls.GL(X=X,y=y,ncp=ncp,ppnu=ppnu,indG=indG,norm="A",verbose=TRUE)
n <- dim(X)[1]
p <- dim(X)[2]

str(mod.dsplsA)

### plotting the observed values VS predicted values
plot(y,mod.dsplsA$fitted.values[,6], xlab="Observed values", ylab="Predicted values",
 main="Observed VS Predicted for 6 components")
points(-1000:1000,-1000:1000,type='l')

### plotting the regression coefficients
par(mfrow=c(3,1))

i=6
nz=mod.dsplsA$zerovar[,i]
plot(1:dim(X)[2],mod.dsplsA$Bhat[,i],type='l',
    main=paste(" Dual-SPLS (GLA), ncp =", i, " #0coef =", nz[1], "/", dim(X1)[2]
    , " #0coef =", nz[2], "/", dim(X2)[2]),
    ylab='',xlab='' )
inonz=which(mod.dsplsA$Bhat[,i]!=0)
points(inonz,mod.dsplsA$Bhat[inonz,i],col='red',pch=19,cex=0.5)
legend("topright", legend ="non null values", bty = "n", cex = 0.8, col = "red",pch=19)

# norm B
mod.dsplsB <- d.spls.GL(X=X,y=y,ncp=ncp,ppnu=ppnu,indG=indG,
gamma=c(0.5,0.5),norm="B",verbose=TRUE)

str(mod.dsplsB)

### plotting the observed values VS predicted values
plot(y,mod.dsplsB$fitted.values[,6], xlab="Observed values", ylab="Predicted values",
 main="Observed VS Predicted for 6 components")
points(-1000:1000,-1000:1000,type='l')

### plotting the regression coefficients
par(mfrow=c(3,1))

i=6
nz=mod.dsplsB$zerovar[,i]
plot(1:dim(X)[2],mod.dsplsB$Bhat[,i],type='l',
    main=paste(" Dual-SPLS (GLB), ncp =", i, " #0coef =", nz[1], "/", dim(X1)[2]
    , " #0coef =", nz[2], "/", dim(X2)[2]),
    ylab='',xlab='' )
inonz=which(mod.dsplsB$Bhat[,i]!=0)
points(inonz,mod.dsplsB$Bhat[inonz,i],col='red',pch=19,cex=0.5)
legend("topright", legend ="non null values", bty = "n", cex = 0.8, col = "red",pch=19)

# norm C
mod.dsplsC <- d.spls.GL(X=X,y=y,ncp=ncp,ppnu=ppnu,indG=indG,norm="C",verbose=TRUE)
n <- dim(X)[1]
p <- dim(X)[2]

str(mod.dsplsC)

### plotting the observed values VS predicted values
plot(y,mod.dsplsC$fitted.values[,6], xlab="Observed values", ylab="Predicted values",
 main="Observed VS Predicted for 6 components")
points(-1000:1000,-1000:1000,type='l')

### plotting the regression coefficients
par(mfrow=c(3,1))

i=6
nz=mod.dsplsC$zerovar[,i]
plot(1:dim(X)[2],mod.dsplsC$Bhat[,i],type='l',
    main=paste(" Dual-SPLS (GLC), ncp =", i, " #0coef =", nz[1], "/", dim(X1)[2]
    , " #0coef =", nz[2], "/", dim(X2)[2]),
    ylab='',xlab='' )
inonz=which(mod.dsplsC$Bhat[,i]!=0)
points(inonz,mod.dsplsC$Bhat[inonz,i],col='red',pch=19,cex=0.5)
legend("topright", legend ="non null values", bty = "n", cex = 0.8, col = "red",pch=19)


}
\seealso{
\code{\link[=d.spls.GLA]{d.spls.GLA()}}, \code{\link[=d.spls.GLB]{d.spls.GLB()}}, \code{\link[=d.spls.GLC]{d.spls.GLC()}}, \code{browseVignettes("dual.spls")}
}
\author{
Louna Alsouki FranÃ§ois Wahl
}
